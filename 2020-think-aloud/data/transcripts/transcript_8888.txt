Interviewer:        00:00          And if you could just say for the recording whether or not you're okay being recorded.

Subject:            00:04          I am okay being recorded.

Interviewer:        00:05          Cool. Thank you. All right, great. Um, so we can get started. Um, so I'll give you this first sheet and um, you put down the time that we're starting

Subject:            00:15          Okay, it's 1:05

Interviewer:        00:15          and then just think aloud or speak aloud your thoughts as you go through and read the code.

Subject:            00:21          [Snippet 73] Okay. We have V one is equal to zero. V two is equal to zero if V two assigned equals one. Okay. So this I mean [laughter] compiles, but it would be picked up by the linter. Um, so we're going to reassign V two equals one. So at this point we have V one equals 0 and V two now equals one. This is one. So we will take the true branch of the if. Um, so now V one is going to be equal to three and then we're going to print if V one, which should be three. So the program output should be three and we're done at 1:05. I am quite confident in this.

Interviewer:        01:07          Great. Okay. So after each question, um, I'll just sort of ask you why you selected that uh level of confidence.

Subject:            01:13          Okay, um, cause I've screwed this up before [laughter] and uh, you know, and this is why I turned on lint options. So because compilers are really good at spotting things like this, but I'm not terrible at it, but you know, it's bad when you do that and it's like, ah, yeah, it's been a while since I've written one of those, but.

Interviewer:        01:34          Okay, cool. Um, well actually so, out of curiosity. It's been a while since you've written one of those, but have you ever seen one of those recently? Or is that something that was sort of in the past?

Subject:            01:45          I mean honestly inside [Large Software Company], like the default compiler options will flag that and tell you you're full of bs unless you put the extra parens around it. So, um, yeah, I just, I never see it anymore when, when other people send me CLs to review and I don't, I mean I don't remember the last time I written it cause I'm pretty conscientious about not doing it. Like, I don't have any of the Pascal like crap in my head anymore, so gotcha. Don't, don't write that.

Interviewer:        02:12          So did you use to write Pascal?

Subject:            02:15          Long, long time ago when I was a kid, the program, but like I haven't used it in probably 20 years at this point. Um,

Interviewer:        02:26          but it's still in there somewhere.

Subject:            02:28          It's somewhere, somewhere. I mean, there are other languages they use equals for that, but I think, I think it's kind of dying. Like basic

Interviewer:        02:38          Prolog maybe.

Subject:            02:41          Maybe prolog, I don't know.

Interviewer:        02:43          But they're few and far between.

Subject:            02:44          Yeah. It's, yeah, it's, it's kind of receding and I don't think of that as equals anymore.

Interviewer:        02:49          Sure. Okay. Well, yeah. Awesome. Awesome explanation. Um, okay, cool. We can move onto the next one. Yeah,

Subject:            03:07          [Snippet 11] Okay. Here we go. Oh, Jesus. [Laughter] Um, okay. Um, so we're going to set, V one equal to zero and then we have a condition and then we're going to either assign it to six or three and then we're going to print the output. So it's either six or three. And the problem is that we have this, uh, uh, precedence, problem, which you would have to have memorized the operators. And so,

Subject:            03:40          Uh,

Subject:            03:44          I don't think anybody's ever been crazy enough to write a language in which And has lower precedence than Or. So I'm going to say that the And gets a weight. Does this not even matter? Yeah. So I'm gonna say that the And before Or I think,

Subject:            04:07          cause I literally don't remember any examples where was the other way? Um, and so that means that this is really like this, sorry, I'm notating on the program,

Interviewer:        04:17          No, no, you're welcome to

Subject:            04:17          but then that's going to be zero and then that's going to be zero or two. So it's going to six, um, six. Um, oh I didn't notate the start time, sorry.

Interviewer:        04:28          It's ok, we probably have it on the recording. Yeah, that's fine.

Subject:            04:34          Um, okay. So the answer I think is going to be six, but I am not perfectly confident. So it was a five.

Interviewer:        04:45          Well it's, I guess first thing is, uh, can you just justify why the confidence level five?

Subject:            04:50          Um, so the confidence level five, I'm not 100% sure because I do not have those precedences memorized because again, there's a warning and the by-default compiler options that will yell at me if I write things like that. Um, because they're not typically clear. Um, that being said, I'm reasonably confident, um, because there is a, I mean, if you're working over the ring of booleans then, And is sort of like multiplication Or is sort of like addition and multiplication is higher precedence than addition. So it's like, it would be very unusual I think, to like reverse to like to (a) define a precedence order, which I know C does, because this compiles and then (b) like reverse it like that, so that like, the multiplicative thing had lower precedence than the additive, but like, I'm not 100% sure. So I didn't want to put six.

Interviewer:        05:44          Sure. Okay. That makes it, that makes sense. Um, out of curiosity, um, so, uh, And and, Or could have different, like hypothetically, they could have different precedence or they could have same precedence. Um, so for example, you could, you could have a line of code that was like one minus two minus three and minus clearly has the same precedence is minus, um, but there, um, due to the associativity

Subject:            06:16          yeah, uh that's a good point. I don't think I've ever seen that either

Interviewer:        06:21          one minus two minus three?

Subject:            06:22          No, no, no, no. I mean, uh, like And and Or having exactly the same precedence without it.

Interviewer:        06:26          Okay. well, that was going to be my question to you.

Subject:            06:29          Yeah. I mean, let's see. So if it were,

Subject:            06:35          mmm,

Subject:            06:39          let's see, if from a short circuiting perspective, does it matter? Yeah. It must matter. How would they associate, um

Interviewer:        06:46          that? Yeah.

Subject:            06:48          Yeah. I would, I tend to think of a left associativity as slightly more natural than right associativity. Um, except for like exponentials, but these are, I mean, plus and times are left associative and I would be, I'm I'm like 95% sure they're not the same precedence, but even if they were, I'm pretty sure they should be left associative. Like, if that makes any sense.

Interviewer:        07:17          Yeah. Yeah, no, totally

Subject:            07:19          I would be surprised if it, if it were both, uh, same precedence and right associative, which is the only way we would get three here. So I'm reasonably confident that it's six.

Interviewer:        07:28          Cool. Okay. Awesome. Thank you.

Subject:            07:37          [Snippet 14] All right, here we go. Okay. So V one is equal to three cool, uh, V two is equal to V one plus four. Okay. So that's what, seven. Okay. So now we increment v one. So V one equals 4, um, yeah. So now I'm going to print V one and V two? So it's going to be what, four and seven? Cool.

Subject:            08:18          Yeah. Yeah. Pretty sure of this.

Interviewer:        08:21          Um, and can I ask you why you're six confident about this?

Subject:            08:25          Um, okay. So basically whenever so C evaluates things in order, it's not a functional programming language. So like this V one is V one at the time that we were, that we were at this statement, it, um, we knew that the one was three before that. Um, so once V one gets incremented here, like we've already computed the value for V two because of the ordering that C places on things. Um, so yeah, I mean I think there's kind of no room for funny business here, so I'm very confident.

Interviewer:        09:05          Sure. That makes sense. Um, one one thing that I didn't quite understand about your explanation, it was you said C's not a functional programming language. Um, so it has to,

Subject:            09:14          so like if you wrote, I mean, I mean there's no way to write plus plus in Haskell cause it's like mutating it. But I'm like this isn't, I mean like hypothetically one could imagine a programming language, I mean maybe functional is a wrong term, but like if maybe lazy is the right word, um, where like this is three and this is a thunk. That's like V one plus four and then we actually increment V one here for some reason. Like, and then there's some, some weird ordering thing, but like C, C is not like that. That's not one of those languages. So

Interviewer:        09:49          I see. Okay.

Subject:            09:51          Um, you know, and then we would like force V one, like hypothetically, like I'm making up some, some bs here, but like if this printf were evaluated left to right, then we force V one first and then we forced V two and um, no, if we, sorry if we went right to left, which is like, you know, is that how Java does it? I don't remember, but like we forced V two first. No, no. If we forced v one first, then do you want to gets incremented and then we forced V two and then this thunk like this is four now or something.

Interviewer:        10:22          Yeah.

Subject:            10:23          You can make a contrived explanation, but like, I know that's not what's happening. Um, yeah. So I'm very confident

Interviewer:        10:30          I see what you mean though, I think. Non-strict.

Subject:            10:33          Yes. Non-strict.

Subject:            10:35          Sorry. My, Haskell's like my one example of a functional programming language, I have not explored the, because I mean, yeah, because you can't, I mean lazy and side effectful is kind of,

Interviewer:        10:48          oh, that's dangerous zone.

Subject:            10:49          It's the danger zone. You should never do that.

Interviewer:        10:52          That's actually, I think you, you get that in like Java or probably even C with streams, like effectful stream. So if you have like streams that like,

Subject:            11:01          Yeah. And I have not cut myself with that particular knife but I can assure you that I am raring to go.

Subject:            11:07          [Snippet 1] All right. V one is equal to zero again. All right. So if 10 mod three cool. That's going to be one. So if V one is going to be four

Subject:            11:20          um, and yeah.

Interviewer:        11:27          Okay Great. And um, can you explain why that level of confidence?

Subject:            11:31          Okay. Um, so this I know this is the mod operator. I know what it does. Um, it's too positive numbers so there's no, yeah, all of those funny business edge cases are not in effect here. The standard says that, you know, well if I remember right it's basically it has to be Euclidean, well no, what, what does the C say? I read this [inaudible]. I mean it's truncating division and like, and then this is like the corresponding remainder operation. Um, I think its trunca..., well I know its trunca.... Okay. For positive, for positive, when both arguments are positive I know it truncates. Um, so 10 10 divided by three is what? Three and a third? Um, so it'll get like the remainder will be one for sure. I'm like, yeah, this, this is the case of the module operator I really understand

Interviewer:        12:29          Of all the possibilities,

Subject:            12:30          which is a true value. So that we set v one to four.

Subject:            12:33          Um, yeah.

Interviewer:        12:35          Cool. That's great. Thank you.

Subject:            12:39          Do I really know this? Is this secretly undefined behavior? No.

Subject:            12:46          [Snippet 55] All right, here we go.

Interviewer:        12:49          Can you write one 1:17

Subject:            12:54          Ok, so V one is zero V two is eight. If, ugh [frustration], okay, so that's going to be five times seven minus V two, seven minus V two is minus one, I think. Yes. Okay. So five minus one is less or equal to zero. So that's minus five, less than equal to zero. So that's the true branch. So we set V one equals four get four and we're done.

Interviewer:        13:34          Great. And then yeah. Can, can you say why?

Subject:            13:38          Yeah, so I guess I feel like this is sort of just math. The only thing that can go wrong here is if these are unsigned types and then all hell breaks loose, but they're not int is a sign type by default.

Subject:            13:48          So I don't really see a lot of room for funny business here. This works the same way in a lot of programming languages.

Interviewer:        13:56          So what, what hell could break loose with unsigned ints?

Subject:            13:59          Okay. So like if we change these to unsigned, then, uh, let's see what happens.

Subject:            14:07          Um, oh good Lord. Um,

Subject:            14:11          well I'm pretty sure the answer wouldn't be zero. So, um, but okay, so this five times, well, so this seven minus eight here would wrap to, um, whatever the maximum value was of the unsigned type it would be a power of two minus one. Um, and then we would multiply it by, let's say, I guess V two minus three, would still be, so it'd be five less than the power of two. That's the one plus the max. So it's, it would sorta be minus five, but as an unsigned number. Um, and that would definitely compare greater than zero. So we would take the other branch of the else. Yeah.

Interviewer:        14:50          Yeah. But it's completely a hypothetical

Subject:            14:52          Hypothetical, it's signed integers, so, okay. Yeah.

Interviewer:        14:59          Awesome. Thank you.

Interviewer:        15:05          Alright, time is 1:20 okay.

Subject:            15:15          [Snippet 56] V one is zero V two is six, V two is six, yes.

Subject:            15:28          Or V two is greater, I don't even need to evaluate that.

Subject:            15:33          Yeah. Okay. So it's going to be V two equals two V one equals two, uh print it. So two

Subject:            15:48          Very positive.

Interviewer:        15:50          Okay. And can you justify that? Okay.

Subject:            15:53          Yeah.

Subject:            15:54          Yeah. So if a one is less or equal to six, so, so v two is assigned to be six. Um, and then we look at the if, it one is less than or equal to six because that's V two's current value. Um, and that's true. And then we short circuit that or so I don't even care what this condition is. Um, I guess it's true as well cause v two, six is also greater than equal to five. Um, then we assign V one equal to two and then we come down here and then V one is two,

Subject:            16:28          so print it.

Interviewer:        16:31          Great. Thank you.

Interviewer:        16:39          It looks like we have two more. I guess the time is 1:21.

Subject:            16:50          [Snippet 37] Okay, well this is going to be a straight textual substitution here, which is three minus one times two. So that is going to be three minus two, which is going to be equal to one. So we print one.

Interviewer:        17:09          Okay, so why, why six confidence?

Subject:            17:11          Um, cause I have used the, I mean, so I learned the hard, well I mean at some point in my distant education, I learned the hard way, uh, to put parentheses around, um, uh, constants that you define like that because um, it's uh, the, the macro preprocessor is literally just like doing textual substitutions, which is what I've done over here. So I've taken it, said, okay, I'm one of the macro, I'm just going to dump literally the sequence of Tokens, three minus one into there. And then I'm going to actually try to parse it because it's sort of lexing like macro expansion. I guess there's some, I'm not really sure how it fits into the lexing and parsing. Like it's a mess. It's a complete mess. I know, but I know that this is a like a straight substitution and not, um, and not like semantically, you know, three minus one, I know that this like will not get evaluated when it gets substituted. Um, cause that's, that's what, that's what it does. Like. I don't know.

Interviewer:        18:15          Yeah, no, you did say at some point in my education did you mean just something

Subject:            18:21          I meant like a long time ago? Like I, I'm sure I made a bug like that where I just left off the parens and then it just broke something. You just do these things once the wrong way, you get cut and then you just kind of remember like, Oh that looks bad. Like I, yeah, I mean, yeah.

Interviewer:        18:40          And so you're kind of go to now is to,

Subject:            18:42          is I'm like if there's no parens, like I'm instantly like red alert like what's going on. Yeah. So,

Subject:            18:49          yeah. Okay. Awesome. Thank you. And then we'll get the last one. Time 1:23.

Subject:            19:05          [Snippet 105] Oh, octal constants [disgusted tone], ugh, okay. That's going to be eight times one plus three to 11, that should be 11.

Subject:            19:18          Cool.

Interviewer:        19:24          Okay, great. And so why six confidence?

Subject:            19:26          Um, yeah, that's an octal constant. Yeah, it's a particularly obnoxious octal form. Um, um, "why?", I mean like, I used octal constants before, I don't know. I mean it's, I I remember pointedly, that it's different in python because you'd write it as zero you know, like that [0x13 on paper], cause like you can write like a hex constantly with an X in C, um, but yeah, they were big on octal man. Um, you know, you want to do like backslash oh one three is a character constant, you know, knock yourself out. But like if you want a Hex, then it would be, I don't know what, um, I guess [writes '\x0b' on paper], yeah, so, you know, shorter, I guess they were like, they really originally developed that thing on a machine with like 36 bit words or something. 18 I don't remember it was weird. It was not a power of two, which is the reason for a lot of the like the C standards saying we're not going to assume that the, that the word width is the power of two. And uh, yeah. So like, you know, 36 bits, man, you know, divide them into groups of three. It's very convenient. Um, yeah, I guess that they were big on octal.

Interviewer:        20:43          Like EBCDIC was probably no, BCD was, was six bits I think, which is two octal.

Subject:            20:53          Yeah, yeah. Um, oh yeah, that's right. They ran on their shitty old character sets. Oh my God. [Laughter]

Interviewer:        20:58          Yeah. Right. I mean before Ascii.

Subject:            21:00          Right. Yeah, hence, yeah. Cause they have trigraphs and I mean now we don't.

Interviewer:        21:06          Oh wait, trigraphs have been removed?

Subject:            21:08          Uh, well have they been removed? I don't know. I never see them. Like, they're sooo old. I think they finally did actually,

Interviewer:        21:17          I mean it's rare that you see non backwards compatible changes to the language. Right?

Subject:            21:21          Yeah. Well I think there was like a little bit of controversial and everybody was just like, really? It's trigraphs, what are you doing? [laughter] Um,

Interviewer:        21:29          I just, I assumed that was something that was popular, not in America because we don't see them here. cause our keyboards or,

Subject:            21:36          Yeah. Yeah. That make sense. I've never, I've never seen them in the wild except in like obfuscated C competitions. Everybody. But like even they got over them like 20 years ago. It was, wow, you can obfuscate everything with this technique. Okay. Let's find more clever ways to obfuscate things. So they got bored. Um, yeah, no, I mean I really hate this feature, but like, yeah, I'm sure that this is how the works. Yeah. And uh, so yeah. Just do the math.

Interviewer:        22:08          That was great. Awesome. Thank you.

Interviewer:        22:13          Um, okay, so if I could have you fill out just like a little thing about your experience. Okay. And then, um, maybe we can go back through and talk about some of the more interesting ones there.

Subject:            22:24          Okay. All right, your age.

Subject:            23:29          I it, it doesn't need to be one of those options. it's whatever suits you.

Subject:            23:33          Yeah. Programmer's fine.

Subject:            23:36          I'm attached to a research org. Um, but I don't, I'm not engaged in a lot of research myself, so like something like dabble in it. But basically, how many credits, did you take in which you had to program? Oh Jesus? All the like both? So I did a phd too so should I count those like

Interviewer:        23:57          Yeah? Yes, yes. The answer is yes.

Subject:            24:00          Let me give you an approximate count. This may take awhile.

Interviewer:        24:04          Approximate is totally fine.

Subject:            24:07          Okay. Well let's see if I, that's going to be like 30

Interviewer:        24:23          it's easier when we asked this to a freshman.

Subject:            24:25          Yes. Much easier.

Interviewer:        24:28          Um, one and a half.

Subject:            24:30          Um, yeah, no, I would jeez. All right. Um,

Interviewer:        24:34          I mean an approximate number is fine.

Subject:            24:36          I don't want to like make something completely up, but let's, let me look at the major current meter requirements.

Subject:            24:45          Hopefully they haven't changed. Okay. That's a good start. Yeah, I'm going to guess it was around 20.

Interviewer:        25:28          Seems plausible. Certainly.

Subject:            25:29          Um, yeah, it's, "How did you to learn to program?" I mean, what, what kind of like self taught, is that a legitimate answer?

Interviewer:        25:41          Completely legitimate if that's the truth, if it's not the truth, then it's less legitimate.

Subject:            25:46          So like, yeah, I mean basically mostly, but I mean I had some help from my parents, they're also programmers, well they're professors of computer science, so they had textbooks lying around, and I basically taught myself, but like they would advise me sometimes. But self taught mostly.

Interviewer:        26:05          But it sounds like a combination of sort of trying it yourself and also reading and also,

Subject:            26:14          Yeah, yeah. Um, preferred programming language. I use c plus plus a lot. But I don't know if I prefer it. I mean, you know, I'll just put that because that's currently my weapon of choice. Oh, oh, I guess that's the next question. Yeah. C plus plus. I guess the last thing that I, well I don't know, like I, I tend to either use c plus plus or python depending on what I'm doing, but it really kind of depends and sometimes Go. "Think about the largest c plus plus program you've ever written contributed to", good lord. I just, I can't even give you an answer to that.

Interviewer:        26:58          If it makes you uncomfortable you can skip it.

Subject:            27:04          Ah, I mean like, yeah. I mean, I don't feel like 2 billion is a useful answer. Like this is what happens when you have a mono-repo. Yeah, I'm just going to skip it.

Interviewer:        27:18          I mean, to be honest, 2 billion isn't the wrong answer.

Subject:            27:23          Yeah, right. I mean, well, and the right answer, the right answer. Maybe, uh, uh, non-disclosable anyway, "How many lines of code did you contribute", oh jeez,

Interviewer:        27:41          Vague answers are totally fine.

Subject:            27:44          Ok, tens of thousands.

Interviewer:        27:45          Yeah, that's, that's great.

Subject:            27:52          "How would you estimate your programming proficiency, general programming". I think I'm

Subject:            28:08          All right. I'm not, I'm not an expert in c plus plus, but I know a lot and I don't want to put six, like Bjarne thinks he's only a seven out of 10 I'm like how can I justify this? But

Subject:            28:32          General, general programming. I don't even know what general program. I'm like really good at this. I don't know. Like this is totally uncalibrated but I'll give myself another five. Why not relative to second year programming students way better. Relative to professional programmers I'll give myself a four probably underselling myself. Have you ever been a professional program? Yes. If so for how long? Let's see. Four plus years. Have you ever been in professional programmer using primarily C plus plus. Yes, sadly. How long? Okay, one of the other years I was using Go, so let's say three plus years. When did I learn C? Good lord. [Laughter]

Interviewer:        29:52          again, ballpark answers are totally fine here.

Subject:            29:56          Uh, Geez. Um,

Subject:            30:09          yeah.

Subject:            30:15          Um, okay. C, what would be a ballpark, let's see. 1995 plus or minus. Active number of years. What do you define as active?

Interviewer:        30:35          Um, where you're actually using it. So a year in which you're only programming python you haven't touched. C would not count.

Subject:            30:44          well I would think most of them cause I write at least small C programs constantly.

Interviewer:        30:50          So keeping it fresh in your mind.

Subject:            30:51          Um, what is that to that 2019 outright? It's like what, 24 years or am I committing a fence post. You just round that down. 23, who cares.

Interviewer:        31:05          Yeah, off by one here is not a big deal here

Subject:            31:08          lines. I don't know. Hundreds of thousands, probably not a million.

Subject:            31:13          I may have thrown away a million lines of code, but I think

Interviewer:        31:17          Your code or other people's code?

Subject:            31:18          My code.

Interviewer:        31:19          So then you must have authored a million lines of code. If you, if you can delete a million lines of your own code, you must

Subject:            31:25          No, but not in one go. I mean like as I was like programming, I would write something out and be like, this sucks. And then delete it and then write it again and then, yeah, but not like finish lines of code, if that makes any sense.

Interviewer:        31:36          That's true. Let's say code lines of code that has been compiled,

Subject:            31:42          Lines of code that had been compiled. I mean I often compile them too, but I'll just say like high hundreds of thousands,

Interviewer:        31:49          Alright

Subject:            32:00          Uh, Haskell, 1999 before it was cool. Not a lot of years active though. Um, well surprising number, maybe it's all through high school and through most of undergrad. So probably about 10 there. And then, uh, I think probably a couple of more years where I used it off and on in graduate school. Uh, I guess around 15. Um, probably tens of thousands. I would say.

Subject:            32:58          C plus plus, obviously. Though. Uh, it might have dabbled in it for school, but I don't, I wouldn't say that I really learned it until I became a professional programmer here. So I'm gonna write 2015 and three years active. Like, um, I would guess on the order of 100,000, lines of, yeah.

Subject:            33:32          Give or take. Yeah.

Subject:            33:34          Wasn't my main weapon like C was for a long time. Learned Java at some point. I don't even remember. It's been too long, I think when it was new.

Subject:            33:49          MMM.

Subject:            33:52          Yeah. I remember specifically having like a book describing Java 1.0 on summer vacation, which must've been what, like 96 97 at one point.

Interviewer:        34:04          Java 1.0, yeah.

Subject:            34:08          I'm just guessing wildly here. Let's say 97 act a number of years. I don't know. I mean I made a bunch of little crappy applets and I kind of got bored with it. Um, and like, then like I'll pull it out sometimes for stack overflow, but like really not very often.

Interviewer:        34:32          Um, pull it out to answer questions?

Subject:            34:33          If somebody has an algorithm question and they want like a Java implementation and I feel like I can do a Java implementation without annoying my self too much, then I'll do it. Um, I don't know. I'm guessing wildly at this point. Sure. Like six. Yeah.

Interviewer:        34:51          Um, are you pretty active on stack overflow?

Subject:            34:55          Yeah, probably too active if you ask my boss, but actually he doesn't know. It's don't tell them.

Interviewer:        35:01          Let's see. Um, it seems to be a trait of a lot of highly productive coders though.

Subject:            35:10          Yeah. I mean we hired XXX for sure.

Interviewer:        35:14          Right. I can't imagine he does anything but answer.

Subject:            35:20          Oh Geez. Um, other languages had a TCL phase. I don't even remember. Had to use it for like a couple years in high school to make interfaces.

Interviewer:        35:32          You don't have to feel obligated to put down one script one time.

Subject:            35:37          Oh no, it was like I was in regular use to make GUIs [goo-eez] at one point, but like, you know, like, I don't know, three years high school was what, 2000 probably probably thousands of lines of TCL too.

Subject:            36:10          Trying to apply a notability filter to this. There's a lot of different ones that I like used, I guess logo belongs on there. When did I learn logo? I was, that was like my first programming. No, Pascal was, pascal was like,

Interviewer:        36:30          Oh that's true. You mentioned that earlier today.

Subject:            36:33          Um, that would have been like 90, I think active years just been too long. I'm guessing probably tens of thousands, but like it's all on the great bit bucket in the sky. So I really couldn't tell you logo. Say, I don't know. I came a little bit later, maybe 1993 active years, maybe about 10. Really loved that thing. Probably tens of thousands of lines of that too.

Interviewer:        37:11          Little Turtle.

Subject:            37:19          Trying to think what I've left off scheme at one point. Um, yeah, there's just so many, like I learned APL like literally when I was sick one week for a programming contest and then never used it again.

Interviewer:        37:42          Did you say APL?

Subject:            37:43          APL. Yeah.

Interviewer:        37:46          I don't even know how people literally make the programs.

Subject:            37:50          Um, there was like a special program with like, they would set up your keyboard in this weird way, like tab at it. It's all unicode now.

Interviewer:        37:57          Oh, is it now? Yeah, but even still, I don't know how to enter those character.

Subject:            38:01          Well yeah, you learn quickly.

Subject:            38:06          I Dunno. Like trying to remember, oh, how can I forget? Go. I used that professionally for let's say two years. One, one. Whereas at the startup, XXX. Let's see. So that would have been 2016, 2017, 2017 no, 2016 you said you've been with XXX for three years. Um, so I was at XXX, so I joined, I joined XXX and January, 2015 then I left for XXX for a year and then I came back. So I see. Okay. Um, so maybe three years, but not consecutive. Yes. Um, how much Go have I written? Honestly, not a lot. I want to say thousands.

Subject:            39:00          How did, I not even put python here. Terrible. I knew I was forgetting something. I mean, I'm just going to stop after python. This is just like, oh jeez.

Interviewer:        39:12          I feel like python might be significant though.

Subject:            39:15          Yes. It, no, I've written hundreds of thousands of lines of python so it's a very [inaudible].

Subject:            39:28          I guess I learned it as an Undergrad. That would have been, let's see, 2004 split the difference and probably every single one of those years I'll say. Yeah. Yeah. I mean there's been some more weird things I learned postscript at one point. Um, probably some other trivial things that I've forgotten. All this crazy little stack programming language to program a robot like simulated robots is like robo-war or something.

Interviewer:        40:12          yeah, sure. No, I think

Subject:            40:15          That gives you the flavor, I think.

Interviewer:        40:16          That gives you the flavor for sure. Okay. Awesome. Well, thanks a lot. Um, so yeah, I would like to go just back and maybe talk about some of the things that didn't come out when we were talking about earlier, um, specifically if there are things that you want to bring up. But any of these things so we can

Subject:            40:36          So the thing I was a little tweaked out by, is that void main is is cool or not? I mean, I'm sure.

Interviewer:        40:41          Oh yeah. Well that's the thing. I mean, technically I don't think it is. Cool. Um, but I didn't want to put a return in these examples, so technically not great.

Subject:            40:55          Okay. All right. Yeah. Yeah. Okay, cool.

Interviewer:        41:00          [Snippet 73] Um, okay. But yeah, so in terms of, um, all, all the inner code, um, do you have any questions about this one? Do I have any?

Subject:            41:11          Yeah, it seems like a pretty straightforward screwup.

Interviewer:        41:15          Yeah. And you did mention, um, it'd be picked up with a linter, which I thought was interesting. Is it, are you talking about a [workplace]-specific one or do you have a open source one that

Subject:            41:27          No, just like Clang warnings. So crank it up high enough, they'll find it. GCC will find, Clang will find it, you know, my shitty compiler that I wrote as a joke, won't find it, but you know, that's why I don't use that in production. So [Laughter]

Interviewer:        41:39          Yeah, probably a good choice. Okay. Awesome. Um, cool

Subject:            41:49          Actually I might've programmed that out of the grammar, I don't remember. Um, yeah, so, so yeah, like I,

Subject:            42:03          [Snippet 11] I remember the, And and Or in, in c are goofy specifically because, um, it used to be overloaded for the logical and the boolean version of the operators, um, way back and maybe you don't like B, and then they later split them, but they didn't update the precedence because it was deemed too much work to fix like the, I dunno, thousand lines or whatever, several thousand lines of code that existed at the time. So we're stuck with all this terrible, uh, precedents ordering on bitwise And and Or, which is why those need a ton of parentheses, but this is the logical version as the operators, and this is a more, yeah. So, yeah. So it would have to be like right associative with the same precedence or, Or over or, Or more tightly than And, and those, I, I, I literally could not name a language where either of those things would be true.

Interviewer:        43:02          Yeah. Well certainly I think about it in the same way that, um, that you mentioned it like in the ring of logic or is equivalent to sort of, yeah. It's addition and then, and sort of maps to multiplication and so yeah, in reality, um, you're right, they do have different precedence and, And binds more tightly. Yeah. So the whole thing about associativity is not relevant, but hypothetically, if they had had the same precedence, you could have that concern, you know?

Subject:            43:40          Definitely. I mean, I, I think I just want to make that like either, I mean, I'm sure, well, I'm not sure. I'm pretty sure it's a warning. Um, and it may, yeah, I think it should be an error. But of course they're never going to make it one, so whatever.

Interviewer:        43:55          Right. No, for sure, that would be nice.

Interviewer:        44:00          [Snippet 14] This one

Subject:            44:04          Pretty straightforward

Interviewer:        44:07          Not an on strict language, nor a lazy language. Although I think, I mean modern C plus plus definitely does have laziness in it. Um, in the libraries.

Subject:            44:17          Yeah, but C doesn't. So, yeah.

Interviewer:        44:19          Well, I mean, laziness can be implemented even in strict languages.

Subject:            44:24          I mean it's just particularly gross in C you'd have like a function pointer in some struct and some yeah. You could do it. But there's no place to hide it here. So

Interviewer:        44:37          Well I'm sure somebody is doing. Um, okay.

Interviewer:        44:42          [Snippet 1] Um, any questions about that one?

Subject:            44:46          It's the mod operator. Could have gotten interesting if there were negative or events that I had to think about it.

Interviewer:        44:53          Right. Um, that's an entirely different thing. Um, yeah,

Subject:            45:05          like specifically a negative devisor would like I'd never think about that case.

Interviewer:        45:10          Yeah. Well cause there's sort of those four quadrants of all positive, all negatives, and I have no idea.

Subject:            45:17          And I guess they design it so that like if you flip the sign at both of them, it should do the same thing I think was there,

Subject:            45:26          uh, I don't remember. There's a couple of logical ways to do it. And

Interviewer:        45:31          Because they're also, there's also the remainder operation, which a lot of languages implement, which is different from mod. But those are the only two I've ever seen. So I don't know how,

Subject:            45:42          Well truncating division, there's floor division and there's Euclidean division and Euclidean always wants a, a positive remainder. And then floor division is literally just do the division and take the floor. And truncating I think is literally do the division and then get them get, get whatever the integer part of the result is. The one closest to zero and then, yeah. And then the remainder should always satisfy the equation. You know, the, the numbers equal to the, um, the quotient times the divisor plus the remainder. Yeah. And I, I'm pretty sure that C's operators obey that, although maybe they don't, I don't, I know they do it in python because pythons like floor division, um, anyway, I don't even remember. I like Euclidean division, but I don't think anybody's implemented it.

Interviewer:        46:36          Well, especially for a language that's supposed to be performance oriented

Subject:            46:39          and then you have to have like an extra, you know, predictable branch.

Subject:            46:42          But yeah, like they don't want to slow it down and they just want to give you whatever [inaudible] does. Although, um I guess C plus plus like recently went to truncating only, right? So there was some change in I think in c plus plus 11 or are they just kind of went, they said, no, it's going to be this way. You know, I mean, maybe they got tired of like a couple of, I don't know. I feel like as the compiler writers like exploit this undefined behavior more and then people complain about it and they just lock down the standards because like, if it's, you know, like if the weird behaviors off on some shitty little DSP thing, then whatever, who cares? Like, you know, they'll deal with it and it will be nominally C plus plus. But like, you know, once the compiler writers start making everybody deal with it they like revolt and then the change standard, so. [Laughter]

Interviewer:        47:30          Right. Yes. It's about finding that fine balance

Subject:            47:35          [Snippet 55] Yes. Um, yeah. So this, this is pretty straight forward, no unsigned types, no big numbers.

Interviewer:        47:41          [Snippet 56] Yeah. And so we did discuss what would happen if there was one sign. So, yeah. Any questions?

Subject:            47:54          Yeah.

Interviewer:        47:55          Pretty straightforward. Yeah.

Subject:            47:59          [Snippet 37] Um, yeah, this one.

Subject:            48:04          MMM.

Interviewer:        48:07          Try anything more to say about, I don't think so. Again, we had a good discussion about it.

Subject:            48:12          Just token pasting.

Interviewer:        48:14          [Snippet 105] Yeah. And then last one.

Subject:            48:19          [Long sigh] Yeah, octal. It's a terrible notation for it, but yeah, what can you do.

Interviewer:        48:28          Yeah. So, cool. Well, so at this point, um, I can turn off the, uh, the recordy thingy. What do you call that?

